{"name":"Livelog","tagline":"continuous log serve prototype in go... ","body":"# livelog\r\n<img hspace=\"20\" align=\"left\" src=\"https://tools.taskcluster.net/lib/assets/taskcluster-120.png\" />\r\n[![Build Status](https://travis-ci.org/taskcluster/livelog.svg?branch=master)](http://travis-ci.org/taskcluster/livelog)\r\n[![GoDoc](https://godoc.org/github.com/taskcluster/livelog?status.svg)](https://godoc.org/github.com/taskcluster/livelog)\r\n[![Coverage Status](https://coveralls.io/repos/taskcluster/livelog/badge.svg?branch=master&service=github)](https://coveralls.io/github/taskcluster/livelog?branch=master)\r\n[![License](https://img.shields.io/badge/license-MPL%202.0-orange.svg)](http://mozilla.org/MPL/2.0)\r\n\r\n## TODO\r\n  - [x] byte range fetching\r\n  - [x] aggregate pending writes into single buffer and/or multiple write\r\n    then flush when no longer writing.\r\n  - [ ] cli\r\n  - [x] cross domain headers\r\n  - [x] http api\r\n\r\nLivelog is a service that enables both secure and insecure streaming of binary\r\ncontent (typically log files) over HTTP(S).\r\n\r\nIt achieves this by exposing an interface for receiving log data via an HTTP\r\nPUT request on tcp port 60022, and exposing a separate interface for reading\r\nthe log via HTTP GET on port 60023.\r\n\r\nIt is written in go, which compiles to a native binary for most conceivable\r\nplatforms, and can therefore be deployed almost anywhere.\r\n\r\nMultiple clients can concurrently access the GET interface, also specifying\r\nHTTP RANGE headers, while only a single client can PUT data. Furthermore, the\r\nlog file content must be served to livelog with a single (long-lived) PUT\r\nrequest. The GET url is only available after the connection to the PUT\r\ninterface has been initiated.\r\n\r\n## URLs\r\n\r\n* PUT: http(s)://localhost:60022/log\r\n* GET: http(s)://localhost:60023/log/`${ACCESS_TOKEN}`\r\n\r\n`ACCESS_TOKEN` is an arbitrary url-safe string that you provide via the\r\n`ACCESS_TOKEN` environment variable to the livelog process when it starts up.\r\nThe provides some level or security via obscurity when managed as a secret\r\nbetween client and server, especially when used in combination with https.\r\n\r\nBy default http is used, unless environment variables `SERVER_CRT_FILE` and\r\n`SERVER_KEY_FILE` environment variables are set, in which case these should\r\nspecify the file location of suitable SSL certificate and key to be used for\r\nhttps transport.\r\n\r\n## Binary packages\r\nSee the [github releases](https://github.com/taskcluster/livelog/releases) page.\r\n\r\n## Example Usage\r\n\r\nTerminal 1: Start service\r\n\r\n```\r\nexport ACCESS_TOKEN='secretpuppy'\r\nexport DEBUG='*'\r\nlivelog\r\n```\r\n\r\nTerminal 2: Pump data into the PUT interface\r\n\r\n```\r\n(for ((i=1; i<=500; i++)); do echo \"Log line $i\"; sleep 1; done) | curl -v -T - http://localhost:60022/log\r\n```\r\n\r\nTerminal 3: Read from GET interface\r\n\r\n```\r\ncurl http://localhost:60023/log/secretpuppy\r\n```\r\n\r\n## Performance\r\n\r\nUnder heavy load while memory does not massively explode it does spike\r\nand due to how go returns memory to the OS the memory will stay at that\r\nlevel for up to 5 minutes. The best case situation is a low number of\r\nclients (or no clients) who stream from beginning to end [this should be\r\nuncommon]. For the more likely case (burst usage) the server is fairly\r\naggressive about closing connections with large amounts of pending data.\r\nThis means that the server can handle massive load and deliver some\r\namount of writes but drop other clients as needed in a mostly\r\nfirst-come-first-server fashion (really also depends on how fast clients\r\ncan read from the socket).\r\n\r\n## Tests\r\n\r\nTests are written in Node.JS largely because I wanted to write some\r\nquickly and node has a great/easy interface to do the nonblocking\r\nhttp stuff I wanted.\r\n\r\nUsage:\r\n```sh\r\nnpm install\r\nnpm test\r\n```\r\n\r\n## Configuration\r\nThe following environment variables can be used to configure the server.\r\n\r\n * `ACCESS_TOKEN` secret access token required for access (**required**)\r\n * `SERVER_CRT_FILE` path to SSL certificate file (optional)\r\n * `SERVER_KEY_FILE` path to SSL private key file (optional)\r\n * `DEBUG` set to '*' to see debug logs (optional)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}